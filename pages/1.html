<!doctype html>
<html lang="en">

  <head>
    <meta charset="utf-8" />
    <title>Blog Test</title>

    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <!-- 1140px Grid styles for IE -->
    <!--[if lte IE 9]><link rel="stylesheet" href="../static/css/ie_1140.css" type="text/css" media="screen" /><![endif]-->
    <!--[if lte IE 9]><link rel="stylesheet" href="../static/css/ie_reset.css" type="text/css" media="screen" /><![endif]-->

    <!-- The 1140px Grid - http://cssgrid.net/ -->
    <link rel="stylesheet" href="../static/css/1140.css" type="text/css" media="screen" />

    <link rel="alternate" type="application/rss+xml" title="infectmac - RSS" href="../rss.xml" />

    <!-- Your styles -->
    <link rel="stylesheet" href="../static/css/styles.css" type="text/css" media="screen" />
    <link rel="stylesheet" href="../static/css/twilight_pygments.css" type="text/css" media="screen" />

    <!--css3-mediaqueries-js - http://code.google.com/p/css3-mediaqueries-js/ - Enables media queries in some unsupported browsers-->
    <script type="text/javascript" src="../static/js/css3-mediaqueries.js"></script>
  </head>

  <body>
    <div class="container">
      <!-- Header -->
      <div class="row">
        <div class="twocol"></div>
        <div class="eightcol blog-header">
          infectmac.com<br/>
        </div>
      </div>

      <!-- Section -->
      <div class="row">
        <div class="twocol"></div>
        <div class="eightcol section">
          <span class="section-header"><a href="../index.html">Blog</a></span>
          <span class="section-header"><a href="../posts.html">Posts</a></span>
          <span class="section-header"><a href="../about.html">About</a></span>
        </div>
      </div>

      
  <!-- Posts -->
  
  <div class="row post-container">
    <div class="twocol"></div>
    <div class="eightcol post">
      <div class="post-title"><a href="../posts/2011-2-7-9-32-objective-c-blocks.html">objective c blocks</a></div>
      <div class="post-date">February 07, 2011</div>
      <p>Objective-C features anonymous functions via what they call blocks. I was a little fuzzy on the memory management rules of blocks at first. The basic rules are: the block structure is stack allocated and blocks retain Objective-C objects they reference until the block is deallocated. In order to keep the block around beyond the lifetime of a stack frame the block must be copied to the heap All of the objects directly referenced within the block will be retained. When the block is released those objects will also be released. Keep in mind the retained objects may have weak references to other objects that may end up getting freed before one would expect. For example, an objects delegate is typically not retained. A simple mistake would be to perform an asynchronous action which causes a view to update but has the possibility of the delegate being released before that action has the opportunity to complete With the Flickr app I spoke of <a href="../posts/2011-1-31-8-28-the-great-uitableview-race.html">previously</a> I messed up on both rules. First, my block referenced <code>tableView</code> whose delegate was the view controller. With the code below it will likely fail if the user backs away before all the thumbnails finish loading.</p>
<div class="codehilite"><pre><span class="o">-</span> <span class="p">(</span><span class="n">UITableViewCell</span> <span class="o">*</span><span class="p">)</span><span class="nl">tableView:</span><span class="p">(</span><span class="n">UITableView</span> <span class="o">*</span><span class="p">)</span><span class="n">tableView</span> <span class="nl">cellForRowAtIndexPath:</span><span class="p">(</span><span class="n">NSIndexPath</span> <span class="o">*</span><span class="p">)</span><span class="n">indexPath</span> <span class="p">{</span>

    <span class="p">...</span><span class="n">code</span> <span class="n">to</span> <span class="n">dequeue</span> <span class="n">and</span> <span class="n">setup</span> <span class="n">a</span> <span class="n">UITableViewCell</span> <span class="n">removed</span><span class="p">...</span>

    <span class="c1">//retrieve our Core Data representation of the photo</span>
    <span class="n">Photo</span><span class="o">*</span> <span class="n">photo</span> <span class="o">=</span> <span class="p">[</span><span class="n">Photo</span> <span class="nl">photoWithFlickrData:</span><span class="n">pictObj</span> <span class="nl">inManagedObjectContext:</span><span class="n">context</span><span class="p">];</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">photo</span><span class="p">.</span><span class="n">thumbnail</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">cell</span><span class="p">.</span><span class="n">imageView</span><span class="p">.</span><span class="n">image</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIImage</span> <span class="nl">imageWithData:</span><span class="n">photo</span><span class="p">.</span><span class="n">thumbnail</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="c1">//Photo objects uses Grand Central Dispatch to make a request to </span>
        <span class="c1">//Flickr servers for photo downloads.</span>
        <span class="p">[</span><span class="n">photo</span> <span class="nl">thumbnailWithBlock:</span><span class="o">^</span><span class="p">(</span><span class="n">NSData</span><span class="o">*</span> <span class="n">image</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">cell</span><span class="p">.</span><span class="n">imageView</span><span class="p">.</span><span class="n">image</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIImage</span> <span class="nl">imageWithData:</span><span class="n">image</span><span class="p">];</span>
            <span class="p">[</span><span class="n">tableView</span> <span class="nl">reloadRowsAtIndexPaths:</span><span class="p">[</span><span class="n">NSArray</span> <span class="nl">arrayWithObject:</span><span class="n">indexPath</span><span class="p">]</span> <span class="nl">withRowAnimation:</span><span class="n">UITableViewRowAnimationNone</span><span class="p">];</span>
        <span class="p">}];</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">cell</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>Once the user backs away from the table’s view controller it will be released. It is possible the queue will still be downloading thumbnails. Once a thumbnail is downloaded the block passed to thumbnailWithBlock will be called and attempt to update the table only to have the program crash. Instead of sending the reload message to <code>tableView</code> I send the reload message to <code>self.tableView</code>. In this case self is the view controller for the table view and since it is now reference in the block it will be retained for later use. After using Grand Central Dispatch (GCD) to perform the image fetching I wanted to see how it could be done with <code>NSURLConnection</code>. <code>NSURLConnection</code> handles all of the networking on a separate thread. It notifies the UI thread via various delegate methods of the download progress. I simply changed the <code>thumbnailWithBlock</code> on the Photo object to use <code>NSURLConnection</code> and store a pointer to the block object for use later. When the download finished I called the block with the downloaded data but the program crashed. The reason was I had failed to copy the block to the heap and was getting the <code>EXC_BAD_ACCESS</code> error. The fix was to send a copy message to the block and be sure to release it after using it with the downloaded data. Once I figured that all out I wondered how GCD handled blocks. It must copy them or else it would be getting <code>EXC_BAD_ACCESS</code> errors. Me being curious I went and looked and sure enough they <a href="http://libdispatch.macosforge.org/trac/browser/trunk/src/queue.c#L692">copy</a> the blocks before using them.</p>
    </div>
  </div>
  
  <div class="row post-container">
    <div class="twocol"></div>
    <div class="eightcol post">
      <div class="post-title"><a href="../posts/2011-2-3-1-49-phantom-mapkit-polylines.html">phantom mapkit polylines</a></div>
      <div class="post-date">February 03, 2011</div>
      <p>I was toying around with MapKit today and I am pretty sure I found a bug. MapKit renders an extra line along the equator if a polyline's point has a latitude of zero or an extra line along the prime meridian if its longitude is zero AND if the line width is less than or equal to 1.0. The code snippet to reproduce the issue can be found here:</p>
<div class="codehilite"><pre><span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nl">viewWillAppear:</span><span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="n">animated</span>
<span class="p">{</span>
    <span class="p">[</span><span class="n">super</span> <span class="nl">viewWillAppear:</span><span class="n">animated</span><span class="p">];</span>
    <span class="n">CLLocationCoordinate2D</span> <span class="n">points</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
    <span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">latitude</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">longitude</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">points</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">latitude</span> <span class="o">=</span> <span class="o">-</span><span class="mi">6</span><span class="p">;</span>
    <span class="n">points</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">longitude</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>

    <span class="n">MKPolyline</span><span class="o">*</span> <span class="n">polyline</span> <span class="o">=</span> <span class="p">[</span><span class="n">MKPolyline</span> <span class="nl">polylineWithCoordinates:</span><span class="n">points</span> <span class="nl">count:</span><span class="mi">2</span><span class="p">];</span>
    <span class="p">[</span><span class="n">mapView</span> <span class="nl">addOverlay:</span><span class="n">polyline</span><span class="p">];</span>
    <span class="p">[</span><span class="n">mapView</span> <span class="nl">setRegion:</span><span class="n">MKCoordinateRegionMake</span><span class="p">(</span><span class="n">CLLocationCoordinate2DMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">MKCoordinateSpanMake</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">))];</span>
<span class="p">}</span>

<span class="o">-</span> <span class="p">(</span><span class="n">MKOverlayView</span><span class="o">*</span><span class="p">)</span><span class="nl">mapView:</span><span class="p">(</span><span class="n">MKMapView</span> <span class="o">*</span><span class="p">)</span><span class="n">mapView</span> <span class="nl">viewForOverlay:</span><span class="p">(</span><span class="kt">id</span> <span class="o">&lt;</span><span class="n">MKOverlay</span><span class="o">&gt;</span><span class="p">)</span><span class="n">overlay</span>
<span class="p">{</span>
    <span class="n">MKPolylineView</span><span class="o">*</span> <span class="n">polylineView</span> <span class="o">=</span> <span class="p">[[</span><span class="n">MKPolylineView</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithPolyline:</span><span class="n">overlay</span><span class="p">];</span>
    <span class="n">polylineView</span><span class="p">.</span><span class="n">lineWidth</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">polylineView</span><span class="p">.</span><span class="n">strokeColor</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIColor</span> <span class="n">redColor</span><span class="p">];</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">polylineView</span> <span class="n">autorelease</span><span class="p">];</span>
<span class="p">}</span>
</pre></div>


<p>And also a screenshot of the result:</p>
<p><img alt="phantom" src="../static/img/phantom-lines.png" /></p>
    </div>
  </div>
  
  <div class="row post-container">
    <div class="twocol"></div>
    <div class="eightcol post">
      <div class="post-title"><a href="../posts/2011-1-31-8-28-the-great-uitableview-race.html">the great uitableview race</a></div>
      <div class="post-date">January 31, 2011</div>
      <p>For the iTunes U course on iOS programming I followed along with the homework assignments. The last assignment was a Flickr app that shows photos at popular geotagged locations. I had an issue with UITableViewCell reuse and background threads populating the thumbnail image that I thought was worth sharing.   On iOS in order to improve performance some of the different libraries like UIKit and MapKit have the ability to reuse UI elements once they are no longer on screen. When reuse occurs it is up to the developer to provide new data for the UI element.  My problem was that two or more asynchronous operations could change the same table cell. One solution would be to stop reusing table cells but that is not ideal. As long as I can identify which image should be shown in the cell at a given time I can make sure the correct asynchronous operation updates the cell. Since UITableViewCell derives from UIView it has the tag property which is a NSInteger. The UITableView represents an array of data from Flickr. Before making the asynchronous call I set the cell’s tag to the index in that array it currently represents. Then in the callback function I only update the cell if its tag matches the index for which the asynchronous call was made.   Without this change in place it is possible to scroll through the list rapidly and see the thumbnail change two or three times for a cell while the remaining thumbnail downloads finish. But the last update could be the wrong thumbnail. The code itself is simple and can be found here: </p>
<div class="codehilite"><pre><span class="o">-</span> <span class="p">(</span><span class="n">UITableViewCell</span> <span class="o">*</span><span class="p">)</span><span class="nl">tableView:</span><span class="p">(</span><span class="n">UITableView</span> <span class="o">*</span><span class="p">)</span><span class="n">tableView</span> <span class="nl">cellForRowAtIndexPath:</span><span class="p">(</span><span class="n">NSIndexPath</span> <span class="o">*</span><span class="p">)</span><span class="n">indexPath</span> <span class="p">{</span>
    <span class="k">static</span> <span class="n">NSString</span> <span class="o">*</span><span class="n">CellIdentifier</span> <span class="o">=</span> <span class="s">@&quot;Cell&quot;</span><span class="p">;</span>

    <span class="n">UITableViewCell</span> <span class="o">*</span><span class="n">cell</span> <span class="o">=</span> <span class="p">[</span><span class="n">tableView</span> <span class="nl">dequeueReusableCellWithIdentifier:</span><span class="n">CellIdentifier</span><span class="p">];</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">cell</span> <span class="o">==</span> <span class="nb">nil</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">cell</span> <span class="o">=</span> <span class="p">[[[</span><span class="n">UITableViewCell</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithStyle:</span><span class="n">UITableViewCellStyleSubtitle</span> <span class="nl">reuseIdentifier:</span><span class="n">CellIdentifier</span><span class="p">]</span> <span class="n">autorelease</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="n">NSDictionary</span><span class="o">*</span> <span class="n">pictObj</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">pictures</span> <span class="nl">objectAtIndex:</span><span class="n">indexPath</span><span class="p">.</span><span class="n">row</span><span class="p">];</span>
    <span class="n">NSString</span><span class="o">*</span> <span class="n">title</span> <span class="o">=</span> <span class="p">[</span><span class="n">pictObj</span> <span class="nl">objectForKey:</span><span class="s">@&quot;title&quot;</span><span class="p">];</span>
    <span class="n">title</span> <span class="o">=</span> <span class="p">[</span><span class="n">title</span> <span class="n">length</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="s">@&quot;(no title)&quot;</span> <span class="o">:</span> <span class="n">title</span><span class="p">;</span>
    <span class="n">cell</span><span class="p">.</span><span class="n">textLabel</span><span class="p">.</span><span class="n">text</span> <span class="o">=</span> <span class="n">title</span><span class="p">;</span>
    <span class="n">cell</span><span class="p">.</span><span class="n">detailTextLabel</span><span class="p">.</span><span class="n">text</span> <span class="o">=</span> <span class="p">[[</span><span class="n">pictObj</span> <span class="nl">objectForKey:</span><span class="s">@&quot;description&quot;</span><span class="p">]</span> <span class="nl">objectForKey:</span><span class="s">@&quot;_content&quot;</span><span class="p">];</span>
    <span class="n">cell</span><span class="p">.</span><span class="n">accessoryType</span> <span class="o">=</span> <span class="n">UITableViewCellAccessoryDisclosureIndicator</span><span class="p">;</span>

    <span class="c1">//identify which image the cell should be displaying right now</span>
    <span class="n">cell</span><span class="p">.</span><span class="n">tag</span> <span class="o">=</span> <span class="n">indexPath</span><span class="p">.</span><span class="n">row</span><span class="p">;</span>

    <span class="n">Photo</span><span class="o">*</span> <span class="n">photo</span> <span class="o">=</span> <span class="p">[</span><span class="n">Photo</span> <span class="nl">photoWithFlickrData:</span><span class="n">pictObj</span> <span class="nl">inManagedObjectContext:</span><span class="n">context</span><span class="p">];</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">photo</span><span class="p">.</span><span class="n">thumbnail</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">cell</span><span class="p">.</span><span class="n">imageView</span><span class="p">.</span><span class="n">image</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIImage</span> <span class="nl">imageWithData:</span><span class="n">photo</span><span class="p">.</span><span class="n">thumbnail</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="n">cell</span><span class="p">.</span><span class="n">imageView</span><span class="p">.</span><span class="n">image</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
        <span class="p">[</span><span class="n">photo</span> <span class="nl">thumbnailWithBlock:</span><span class="o">^</span><span class="p">(</span><span class="n">UIImage</span><span class="o">*</span> <span class="n">image</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">//check to make sure the image should be updated</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">cell</span><span class="p">.</span><span class="n">tag</span> <span class="o">==</span> <span class="n">indexPath</span><span class="p">.</span><span class="n">row</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">cell</span><span class="p">.</span><span class="n">imageView</span><span class="p">.</span><span class="n">image</span> <span class="o">=</span> <span class="n">image</span><span class="p">;</span>
                <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">tableView</span> <span class="nl">reloadRowsAtIndexPaths:</span><span class="p">[</span><span class="n">NSArray</span> <span class="nl">arrayWithObject:</span><span class="n">indexPath</span><span class="p">]</span> <span class="nl">withRowAnimation:</span><span class="n">UITableViewRowAnimationNone</span><span class="p">];</span>
            <span class="p">}</span>
        <span class="p">}];</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">cell</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
    </div>
  </div>
  

  <div class="row">
    <div class="twocol"></div>
    <div class="eightcol newer-older">
      <div class="newer-posts" style="visibility:visible;"><a href="../pages/0.html">Newer</a></div>
      <div class="older-posts" style="visibility:visible;"><a href="../pages/2.html">Older</a></div>
    </div>
  </div>


      <!-- Footer -->
      <div class="row">
        <div class="twocol"></div>
        <div class="eightcol blog-footer">
          Copyright © 2012 - Evan Long
        </div>
      </div>
    </div>
  </body>

</html>